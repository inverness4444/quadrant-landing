import { randomUUID } from "crypto";
import { and, asc, desc, eq } from "drizzle-orm";
import { db } from "@/lib/db";
import { reportSections, reports, type ReportSectionKey } from "@/drizzle/schema";
import type { ReportDTO, ReportSectionDTO } from "@/services/types/report";
import { getTeamProfile } from "@/services/teamProfileService";
import { computeTeamNeedsSummary, getWorkspaceJobRoles } from "@/services/movesService";
import { getWorkspaceSkillMap } from "@/services/skillMapService";
import { getWorkspacePilotRuns } from "@/services/pilotService";

export async function getWorkspaceReports(workspaceId: string): Promise<ReportDTO[]> {
  const list = await db
    .select()
    .from(reports)
    .where(eq(reports.workspaceId, workspaceId))
    .orderBy(desc(reports.createdAt));
  return Promise.all(list.map((row) => hydrateReport(row)));
}

export async function getReportById(reportId: string, workspaceId: string): Promise<ReportDTO | null> {
  const report = await db.query.reports.findFirst({
    where: and(eq(reports.id, reportId), eq(reports.workspaceId, workspaceId)),
  });
  if (!report) return null;
  return hydrateReport(report);
}

export async function createEmptyReport(input: {
  workspaceId: string;
  type: "team" | "pilot" | "workspace";
  title: string;
  context?: { teamId?: string; pilotRunId?: string };
  createdByUserId: string;
}): Promise<ReportDTO> {
  const id = randomUUID();
  const now = new Date().toISOString();
  db.insert(reports)
    .values({
      id,
      workspaceId: input.workspaceId,
      type: input.type,
      title: input.title,
      teamId: input.context?.teamId ?? null,
      pilotRunId: input.context?.pilotRunId ?? null,
      generatedFrom: "manual",
      status: "draft",
      createdByUserId: input.createdByUserId,
      createdAt: now,
      updatedAt: now,
    })
    .run();
  const created = await getReportById(id, input.workspaceId);
  if (!created) {
    throw new Error("REPORT_CREATION_FAILED");
  }
  return created;
}

export async function updateReportMeta(input: {
  reportId: string;
  workspaceId: string;
  title?: string;
  status?: "draft" | "finalized" | "archived";
}): Promise<ReportDTO | null> {
  const existing = await db.query.reports.findFirst({
    where: and(eq(reports.id, input.reportId), eq(reports.workspaceId, input.workspaceId)),
  });
  if (!existing) return null;
  db.update(reports)
    .set({
      title: input.title ?? existing.title,
      status: input.status ?? existing.status,
      updatedAt: new Date().toISOString(),
    })
    .where(eq(reports.id, input.reportId))
    .run();
  return getReportById(input.reportId, input.workspaceId);
}

export async function updateReportSection(input: {
  reportId: string;
  sectionId: string;
  workspaceId: string;
  title?: string;
  contentMarkdown?: string;
  orderIndex?: number;
  isAutoGenerated?: boolean;
}): Promise<ReportSectionDTO | null> {
  const report = await db.query.reports.findFirst({
    where: and(eq(reports.id, input.reportId), eq(reports.workspaceId, input.workspaceId)),
  });
  if (!report) return null;
  const existing = await db.query.reportSections.findFirst({ where: eq(reportSections.id, input.sectionId) });
  if (!existing || existing.reportId !== input.reportId) return null;
  db.update(reportSections)
    .set({
      title: input.title ?? existing.title,
      contentMarkdown: input.contentMarkdown ?? existing.contentMarkdown,
      orderIndex: input.orderIndex ?? existing.orderIndex,
      isAutoGenerated: input.isAutoGenerated ?? existing.isAutoGenerated,
    })
    .where(eq(reportSections.id, input.sectionId))
    .run();
  return mapSection({
    ...existing,
    title: input.title ?? existing.title,
    contentMarkdown: input.contentMarkdown ?? existing.contentMarkdown,
    orderIndex: input.orderIndex ?? existing.orderIndex,
    isAutoGenerated: input.isAutoGenerated ?? existing.isAutoGenerated,
  });
}

export async function generateTeamReportSections(input: { reportId: string; workspaceId: string; teamId: string }) {
  const report = await getReportById(input.reportId, input.workspaceId);
  if (!report) {
    throw new Error("REPORT_NOT_FOUND");
  }
  const profile = await getTeamProfile(input.workspaceId, input.teamId);
  const skillMap = await getWorkspaceSkillMap(input.workspaceId);
  const teamMap = skillMap.teams.find((team) => team.teamId === input.teamId);
  const movesSummary = await computeTeamNeedsSummary({ teamId: input.teamId, workspaceId: input.workspaceId });
  void (await getWorkspaceJobRoles(input.workspaceId));
  const sections: Array<{ key: ReportSectionKey; title: string; body: string }> = [];
  const headcount = profile?.metrics.headcount ?? teamMap?.employeeCount ?? 0;
  const topSkills = teamMap?.topSkills.slice(0, 3).map((skill) => skill.name).join(", ") ?? "нет данных";
  sections.push({
    key: "summary",
    title: "Краткий обзор команды",
    body: `Команда: ${profile?.teamName ?? "—"}\nЛюдей: ${headcount}\nНавыки: ${topSkills}\n\nСильные стороны:\n- ${teamMap?.topSkills[0]?.name ?? "нужны данные"}\nГлавные риски:\n- ${
      profile?.metrics.highRiskSkills ?? movesSummary?.summaryMetrics.totalRiskSkillsCount ?? 0
    } навыков в риске`,
  });
  sections.push({
    key: "risks",
    title: "Риски по навыкам и ключевым людям",
    body:
      movesSummary?.keySkills
        .slice(0, 5)
        .map((skill) => `- ${skill.skillName} (bus factor ${skill.busFactor}) — ${skill.owners.map((o) => o.name).join(", ")}`)
        .join("\n") || "- Недостаточно данных для рисков",
  });
  sections.push({
    key: "talents",
    title: "Ключевые таланты и потенциал",
    body:
      profile?.members
        .slice(0, 5)
        .map((m) => `- ${m.name}: сильные навыки ${m.topSkills.slice(0, 2).join(", ")}`)
        .join("\n") || "- Недостаточно данных по талантам",
  });
  sections.push({
    key: "moves",
    title: "Решения: найм, развитие, перемещения",
    body:
      movesSummary?.roles
        .slice(0, 5)
        .map((role) => {
          if (role.hireRequired) return `- Нанять ${role.jobRoleName}`;
          return `- Развивать: ${role.jobRoleName} (кандидатов: ${role.internalCandidatesCount}, min gap ${role.minGapScoreAmongCandidates ?? "—"})`;
        })
        .join("\n") || "- Недостаточно данных по ролям",
  });
  sections.push({
    key: "next_steps",
    title: "Следующие шаги",
    body: ["- Запустить/обновить оценку навыков", "- Сгенерировать сценарий moves", "- Назначить квесты развития", "- Назначить следующую встречу"].join(
      "\n",
    ),
  });
  await upsertSections(report, sections);
  return getReportById(report.id, input.workspaceId);
}

export async function generatePilotReportSections(input: { reportId: string; workspaceId: string; pilotRunId: string }) {
  const report = await getReportById(input.reportId, input.workspaceId);
  if (!report) throw new Error("REPORT_NOT_FOUND");
  const pilotRuns = await getWorkspacePilotRuns(input.workspaceId);
  const pilot = pilotRuns.find((run) => run.id === input.pilotRunId);
  const sections: Array<{ key: ReportSectionKey | string; title: string; body: string }> = [];
  sections.push({
    key: "summary",
    title: "Обзор пилота",
    body: pilot
      ? `Пилот: ${pilot.name}\nСтатус: ${pilot.status}\nКоманд: ${pilot.teams.length}\nПрогресс: ${pilot.summaryProgress.percent}%`
      : "Данных по пилоту нет",
  });
  sections.push({
    key: "pilot_progress",
    title: "Прогресс по шагам",
    body:
      pilot?.steps
        .map((step) => `- ${step.title}: ${step.status}`)
        .join("\n") ?? "- Нет шагов",
  });
  sections.push({
    key: "risks",
    title: "Ключевые риски",
    body: "- Соберите риски из заметок пилота или riskService (TODO автодетализация)",
  });
  sections.push({
    key: "moves",
    title: "Решения и сценарии",
    body: "- Сводка сценариев перемещений и решений (TODO: связать с moves)",
  });
  sections.push({
    key: "next_steps",
    title: "Следующие шаги",
    body: ["- Финализировать результаты пилота", "- Определить план на 3–6 месяцев", "- Запустить квесты по итогам"].join("\n"),
  });
  await upsertSections(report, sections);
  return getReportById(report.id, input.workspaceId);
}

export async function generateWorkspaceReportSections(input: { reportId: string; workspaceId: string }) {
  const report = await getReportById(input.reportId, input.workspaceId);
  if (!report) throw new Error("REPORT_NOT_FOUND");
  const skillMap = await getWorkspaceSkillMap(input.workspaceId);
  const pilotRuns = await getWorkspacePilotRuns(input.workspaceId);
  const sections: Array<{ key: ReportSectionKey | string; title: string; body: string }> = [];
  sections.push({
    key: "summary",
    title: "Общий обзор по организации",
    body: `Команд: ${skillMap.teams.length}\nСотрудников: ${skillMap.totalEmployees}\nНавыков: ${skillMap.totalSkills}`,
  });
  sections.push({
    key: "risks",
    title: "Ключевые риски по навыкам и ролям",
    body:
      skillMap.skills
        .slice(0, 5)
        .map((skill) => `- ${skill.name}: риск ${skill.riskScore}, bus factor ${skill.busFactor}`)
        .join("\n") || "- Недостаточно данных",
  });
  sections.push({
    key: "moves",
    title: "План найма и развития",
    body: "- Используйте модуль Решения, чтобы собрать сценарии найма и развития (автогенерация по рискам)",
  });
  sections.push({
    key: "pilot_progress",
    title: "Пилоты и масштабирование",
    body: pilotRuns.length ? `Активных пилотов: ${pilotRuns.filter((p) => p.status === "active").length}` : "Пилоты не запущены",
  });
  sections.push({
    key: "next_steps",
    title: "Рекомендации для C-level",
    body: ["- Утвердить роли и требования", "- Запустить оценку навыков", "- Согласовать сценарии найма/развития"].join("\n"),
  });
  await upsertSections(report, sections);
  return getReportById(report.id, input.workspaceId);
}

async function upsertSections(
  report: ReportDTO,
  sections: Array<{ key: ReportSectionKey | string; title: string; body: string }>,
) {
  const existing = await db.select().from(reportSections).where(eq(reportSections.reportId, report.id)).orderBy(asc(reportSections.orderIndex));
  let order = 0;
  for (const section of sections) {
    const found = existing.find((row) => row.key === section.key && row.isAutoGenerated);
    if (found) {
      db.update(reportSections)
        .set({
          title: section.title,
          contentMarkdown: section.body,
          orderIndex: order++,
          isAutoGenerated: true,
        })
        .where(eq(reportSections.id, found.id))
        .run();
    } else if (!existing.some((row) => row.key === section.key && row.isAutoGenerated === false)) {
      db.insert(reportSections)
        .values({
          id: randomUUID(),
          reportId: report.id,
          key: section.key,
          title: section.title,
          orderIndex: order++,
          contentMarkdown: section.body,
          isAutoGenerated: true,
        })
        .run();
    }
  }
}

async function hydrateReport(row: typeof reports.$inferSelect): Promise<ReportDTO> {
  const sections = await db
    .select()
    .from(reportSections)
    .where(eq(reportSections.reportId, row.id))
    .orderBy(asc(reportSections.orderIndex));
  return {
    ...row,
    teamId: row.teamId ?? null,
    pilotRunId: row.pilotRunId ?? null,
    generatedFrom: row.generatedFrom ?? null,
    sections: sections.map(mapSection),
  };
}

function mapSection(row: typeof reportSections.$inferSelect): ReportSectionDTO {
  return {
    id: row.id,
    reportId: row.reportId,
    key: row.key ?? null,
    title: row.title,
    orderIndex: row.orderIndex,
    contentMarkdown: row.contentMarkdown,
    isAutoGenerated: Boolean(row.isAutoGenerated),
  };
}
