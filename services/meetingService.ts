import { randomUUID } from "crypto";
import { and, asc, desc, eq } from "drizzle-orm";
import { db } from "@/lib/db";
import {
  meetingAgendaItems,
  meetingAgendas,
  type MeetingType,
} from "@/drizzle/schema";
import type { MeetingAgendaDTO, MeetingAgendaItemDTO } from "@/services/types/meeting";
import type { ReportDTO } from "@/services/types/report";
import { getReportById } from "@/services/reportService";
import { createNotification } from "@/services/notificationService";

export async function getWorkspaceAgendas(workspaceId: string): Promise<MeetingAgendaDTO[]> {
  const rows = await db
    .select()
    .from(meetingAgendas)
    .where(eq(meetingAgendas.workspaceId, workspaceId))
    .orderBy(desc(meetingAgendas.createdAt));
  return Promise.all(rows.map((row) => hydrateAgenda(row)));
}

export async function getAgendaById(agendaId: string, workspaceId: string): Promise<MeetingAgendaDTO | null> {
  const row = await db.query.meetingAgendas.findFirst({
    where: and(eq(meetingAgendas.id, agendaId), eq(meetingAgendas.workspaceId, workspaceId)),
  });
  if (!row) return null;
  return hydrateAgenda(row);
}

export async function createAgendaFromReport(input: {
  workspaceId: string;
  reportId: string;
  type: MeetingType;
  title?: string;
  description?: string;
  scheduledAt?: Date;
  durationMinutes?: number;
  createdByUserId: string;
}): Promise<MeetingAgendaDTO> {
  const report = await getReportById(input.reportId, input.workspaceId);
  if (!report) {
    throw new Error("REPORT_NOT_FOUND");
  }
  const id = randomUUID();
  const now = new Date().toISOString();
  db.insert(meetingAgendas)
    .values({
      id,
      workspaceId: input.workspaceId,
      reportId: report.id,
      type: input.type,
      title: input.title ?? `Встреча по отчёту: ${report.title}`,
      description: input.description ?? null,
      scheduledAt: input.scheduledAt ? input.scheduledAt.toISOString() : null,
      durationMinutes: input.durationMinutes ?? null,
      createdByUserId: input.createdByUserId,
      createdAt: now,
      updatedAt: now,
    })
    .run();
  const items = buildAgendaItemsFromReport(report, input.type);
  let orderIndex = 0;
  for (const item of items) {
    db.insert(meetingAgendaItems)
      .values({
        id: randomUUID(),
        agendaId: id,
        orderIndex: orderIndex++,
        title: item.title,
        bodyMarkdown: item.bodyMarkdown,
        relatedTeamId: item.relatedTeamId ?? null,
        relatedPilotRunId: item.relatedPilotRunId ?? null,
        relatedScenarioId: item.relatedScenarioId ?? null,
        isAutoGenerated: true,
      })
      .run();
  }
  const created = await getAgendaById(id, input.workspaceId);
  if (!created) {
    throw new Error("AGENDA_CREATION_FAILED");
  }
  await createNotification({
    workspaceId: input.workspaceId,
    userId: input.createdByUserId,
    type: "meeting_upcoming",
    title: `Создана повестка встречи: ${created.title}`,
    body: "Не забудьте проверить пункты и подготовиться.",
    entityType: "meeting_agenda",
    entityId: created.id,
    url: `/app/meetings/${created.id}`,
  });
  // TODO: при закрытии встречи, где есть action items по людям, дергать createDecision с sourceType=\"meeting\".
  return created;
}

export async function updateAgendaMeta(input: {
  agendaId: string;
  workspaceId: string;
  title?: string;
  description?: string;
  scheduledAt?: Date | null;
  durationMinutes?: number | null;
}): Promise<MeetingAgendaDTO | null> {
  const existing = await db.query.meetingAgendas.findFirst({
    where: and(eq(meetingAgendas.id, input.agendaId), eq(meetingAgendas.workspaceId, input.workspaceId)),
  });
  if (!existing) return null;
  db.update(meetingAgendas)
    .set({
      title: input.title ?? existing.title,
      description: input.description ?? existing.description,
      scheduledAt: input.scheduledAt === undefined ? existing.scheduledAt : input.scheduledAt ? input.scheduledAt.toISOString() : null,
      durationMinutes: input.durationMinutes === undefined ? existing.durationMinutes : input.durationMinutes,
      updatedAt: new Date().toISOString(),
    })
    .where(eq(meetingAgendas.id, input.agendaId))
    .run();
  return getAgendaById(input.agendaId, input.workspaceId);
}

export async function updateAgendaItem(input: {
  agendaId: string;
  itemId: string;
  workspaceId: string;
  title?: string;
  bodyMarkdown?: string;
  orderIndex?: number;
  isAutoGenerated?: boolean;
}): Promise<MeetingAgendaItemDTO | null> {
  const agenda = await db.query.meetingAgendas.findFirst({
    where: and(eq(meetingAgendas.id, input.agendaId), eq(meetingAgendas.workspaceId, input.workspaceId)),
  });
  if (!agenda) return null;
  const existing = await db.query.meetingAgendaItems.findFirst({ where: eq(meetingAgendaItems.id, input.itemId) });
  if (!existing || existing.agendaId !== agenda.id) return null;
  db.update(meetingAgendaItems)
    .set({
      title: input.title ?? existing.title,
      bodyMarkdown: input.bodyMarkdown ?? existing.bodyMarkdown,
      orderIndex: input.orderIndex ?? existing.orderIndex,
      isAutoGenerated: input.isAutoGenerated ?? existing.isAutoGenerated,
    })
    .where(eq(meetingAgendaItems.id, input.itemId))
    .run();
  return {
    ...existing,
    title: input.title ?? existing.title,
    bodyMarkdown: input.bodyMarkdown ?? existing.bodyMarkdown,
    orderIndex: input.orderIndex ?? existing.orderIndex,
    isAutoGenerated: input.isAutoGenerated ?? existing.isAutoGenerated,
  };
}

function buildAgendaItemsFromReport(report: ReportDTO, type: MeetingType) {
  const byKey = new Map(report.sections.map((section) => [section.key ?? "", section]));
  const pickBody = (key: string) => byKey.get(key)?.contentMarkdown ?? "";
  if (type === "team_review") {
    return [
      { title: "Краткий обзор команды", bodyMarkdown: bullets(pickBody("summary")) },
      { title: "Риски и уязвимости", bodyMarkdown: bullets(pickBody("risks")) },
      { title: "Ключевые таланты и кандидаты", bodyMarkdown: bullets(pickBody("talents")) },
      { title: "Решения: найм/развитие/перемещения", bodyMarkdown: bullets(pickBody("moves")) },
      { title: "Следующие шаги и ответственность", bodyMarkdown: bullets(pickBody("next_steps")) },
    ];
  }
  if (type === "pilot_review") {
    return [
      { title: "Цели и контекст пилота", bodyMarkdown: bullets(pickBody("summary")) },
      { title: "Прогресс по шагам", bodyMarkdown: bullets(pickBody("pilot_progress")) },
      { title: "Ключевые находки и риски", bodyMarkdown: bullets(pickBody("risks")) },
      { title: "Принятые решения и сценарии", bodyMarkdown: bullets(pickBody("moves")) },
      { title: "План действий на 3–6 месяцев", bodyMarkdown: bullets(pickBody("next_steps")) },
    ];
  }
  return [
    { title: "Общий обзор по организации", bodyMarkdown: bullets(pickBody("summary")) },
    { title: "Ключевые риски по навыкам и ролям", bodyMarkdown: bullets(pickBody("risks")) },
    { title: "План найма и развития", bodyMarkdown: bullets(pickBody("moves")) },
    { title: "Пилоты и масштабирование", bodyMarkdown: bullets(pickBody("pilot_progress")) },
    { title: "Рекомендации для C-level", bodyMarkdown: bullets(pickBody("next_steps")) },
  ];
}

function bullets(markdown: string) {
  const lines = markdown.split("\n").filter((line) => line.trim().length > 0);
  return lines.map((line) => `- ${line.trim()}`).join("\n");
}

async function hydrateAgenda(row: typeof meetingAgendas.$inferSelect): Promise<MeetingAgendaDTO> {
  const items = await db
    .select()
    .from(meetingAgendaItems)
    .where(eq(meetingAgendaItems.agendaId, row.id))
    .orderBy(asc(meetingAgendaItems.orderIndex));
  return {
    ...row,
    reportId: row.reportId ?? null,
    description: row.description ?? null,
    scheduledAt: row.scheduledAt ?? null,
    durationMinutes: row.durationMinutes ?? null,
    items: items.map((item) => ({
      ...item,
      relatedTeamId: item.relatedTeamId ?? null,
      relatedPilotRunId: item.relatedPilotRunId ?? null,
      relatedScenarioId: item.relatedScenarioId ?? null,
      isAutoGenerated: Boolean(item.isAutoGenerated),
    })),
  };
}
