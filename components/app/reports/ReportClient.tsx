"use client";

import { useRouter } from "next/navigation";
import { useState } from "react";
import Card from "@/components/common/Card";
import PrimaryButton from "@/components/common/PrimaryButton";
import SecondaryButton from "@/components/common/SecondaryButton";
import Tag from "@/components/common/Tag";
import type { ReportDTO } from "@/services/types/report";

type ReportClientProps = {
  report: ReportDTO;
  currentUserId: string;
  workspaceId: string;
};

export default function ReportClient({ report: initialReport }: ReportClientProps) {
  const router = useRouter();
  const [report, setReport] = useState(initialReport);
  const [error, setError] = useState<string | null>(null);
  const [savingSection, setSavingSection] = useState<string | null>(null);
  const [regenerating, setRegenerating] = useState(false);
  const [agendaForm, setAgendaForm] = useState({
    type: initialReport.type === "pilot" ? "pilot_review" : initialReport.type === "team" ? "team_review" : "exec_briefing",
    title: `Встреча по отчёту: ${initialReport.title}`,
    description: "",
  });

  const updateSection = async (sectionId: string, data: Partial<{ title: string; contentMarkdown: string; orderIndex: number; isAutoGenerated: boolean }>) => {
    setSavingSection(sectionId);
    setError(null);
    try {
      const response = await fetch(`/api/app/reports/${report.id}`, { method: "GET", cache: "no-store" });
      if (!response.ok) throw new Error("Отчёт недоступен");
      const patch = await fetch(`/api/app/reports/${report.id}/sections/${sectionId}`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
      });
      const payload = await patch.json().catch(() => null);
      if (!patch.ok || !payload?.ok) throw new Error(payload?.error?.message ?? "Не удалось сохранить секцию");
      const refreshed = await fetch(`/api/app/reports/${report.id}`, { cache: "no-store" });
      const refreshedJson = await refreshed.json();
      if (refreshed.ok && refreshedJson?.ok) {
        setReport(refreshedJson.report);
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : "Ошибка сохранения");
    } finally {
      setSavingSection(null);
    }
  };

  const regenerate = async () => {
    setRegenerating(true);
    setError(null);
    try {
      const response = await fetch(`/api/app/reports/${report.id}/generate`, { method: "POST" });
      const payload = await response.json().catch(() => null);
      if (!response.ok || !payload?.ok) throw new Error(payload?.error?.message ?? "Не удалось обновить отчёт");
      setReport(payload.report);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Ошибка обновления отчёта");
    } finally {
      setRegenerating(false);
    }
  };

  const createAgenda = async () => {
    setError(null);
    try {
      const response = await fetch("/api/app/meetings/agendas", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          reportId: report.id,
          type: agendaForm.type,
          title: agendaForm.title,
          description: agendaForm.description || undefined,
        }),
      });
      const payload = await response.json().catch(() => null);
      if (!response.ok || !payload?.ok) {
        throw new Error(payload?.error?.message ?? "Не удалось создать повестку");
      }
      router.push(`/app/meetings/${payload.agenda.id}`);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Ошибка создания повестки");
    }
  };

  return (
    <div className="space-y-6">
      <div className="flex flex-col gap-3 md:flex-row md:items-center md:justify-between">
        <div>
          <p className="text-xs uppercase tracking-[0.4em] text-slate-400">Отчёт</p>
          <h1 className="text-3xl font-semibold text-brand-text">{report.title}</h1>
          <p className="text-sm text-slate-600">
            Тип: {formatType(report.type)} · Статус: {formatStatus(report.status)}
          </p>
        </div>
        <div className="flex flex-wrap gap-2">
          <PrimaryButton onClick={() => void regenerate()} disabled={regenerating} className="px-4 py-2">
            {regenerating ? "Обновляем…" : "Перегенерировать авто-секции"}
          </PrimaryButton>
          <SecondaryButton
            onClick={() => void updateMeta("finalized")}
            className="px-4 py-2"
            disabled={report.status === "finalized"}
          >
            Сделать финальным
          </SecondaryButton>
        </div>
      </div>

      {error && <Card className="border border-red-200 bg-red-50 p-4 text-sm text-red-700">{error}</Card>}

      <Card className="space-y-3">
        <div className="flex items-center justify-between">
          <div>
            <p className="text-xs uppercase tracking-[0.3em] text-slate-400">Секции отчёта</p>
            <h2 className="text-xl font-semibold text-brand-text">Структура</h2>
          </div>
        </div>
        <div className="space-y-3">
          {report.sections.map((section, index) => (
            <div key={section.id} className="rounded-2xl border border-white/60 bg-white/90 p-3">
              <div className="flex items-center justify-between gap-3">
                <div className="flex items-center gap-2">
                  <input
                    className="w-full rounded-xl border border-brand-border px-3 py-2 text-sm"
                    value={section.title}
                    onChange={(event) =>
                      setReport((prev) => ({
                        ...prev,
                        sections: prev.sections.map((s) => (s.id === section.id ? { ...s, title: event.target.value } : s)),
                      }))
                    }
                  />
                  <Tag variant="outline">{section.isAutoGenerated ? "Авто" : "Ручная"}</Tag>
                </div>
                <div className="flex gap-1">
                  <SecondaryButton
                    onClick={() => moveSection(index, -1)}
                    disabled={index === 0}
                    className="px-3 py-1 text-xs"
                  >
                    ↑
                  </SecondaryButton>
                  <SecondaryButton
                    onClick={() => moveSection(index, 1)}
                    disabled={index === report.sections.length - 1}
                    className="px-3 py-1 text-xs"
                  >
                    ↓
                  </SecondaryButton>
                </div>
              </div>
              <textarea
                value={section.contentMarkdown}
                onChange={(event) =>
                  setReport((prev) => ({
                    ...prev,
                    sections: prev.sections.map((s) => (s.id === section.id ? { ...s, contentMarkdown: event.target.value } : s)),
                  }))
                }
                className="mt-2 w-full rounded-xl border border-brand-border px-3 py-2 text-sm font-mono"
                rows={6}
              />
              <div className="mt-2 flex items-center justify-between">
                <label className="flex items-center gap-2 text-sm text-slate-600">
                  <input
                    type="checkbox"
                    checked={section.isAutoGenerated}
                    onChange={(event) =>
                      setReport((prev) => ({
                        ...prev,
                        sections: prev.sections.map((s) =>
                          s.id === section.id ? { ...s, isAutoGenerated: event.target.checked } : s,
                        ),
                      }))
                    }
                  />
                  Разрешить автообновление
                </label>
                <PrimaryButton
                  onClick={() =>
                    void updateSection(section.id, {
                      title: section.title,
                      contentMarkdown: section.contentMarkdown,
                      orderIndex: section.orderIndex,
                      isAutoGenerated: section.isAutoGenerated,
                    })
                  }
                  disabled={savingSection === section.id}
                  className="px-3 py-1 text-xs"
                >
                  Сохранить секцию
                </PrimaryButton>
              </div>
            </div>
          ))}
        </div>
      </Card>

      <Card className="space-y-3">
        <div className="flex items-center justify-between">
          <div>
            <p className="text-xs uppercase tracking-[0.3em] text-slate-400">Встреча</p>
            <h2 className="text-xl font-semibold text-brand-text">Создать повестку</h2>
          </div>
        </div>
        <div className="grid gap-3 md:grid-cols-2">
          <label className="text-sm text-slate-600">
            Тип встречи
            <select
              value={agendaForm.type}
              onChange={(event) => setAgendaForm((prev) => ({ ...prev, type: event.target.value }))}
              className="mt-1 w-full rounded-xl border border-brand-border px-3 py-2 text-sm"
            >
              <option value="team_review">Team review</option>
              <option value="pilot_review">Pilot review</option>
              <option value="exec_briefing">Executive briefing</option>
            </select>
          </label>
          <label className="text-sm text-slate-600">
            Название
            <input
              value={agendaForm.title}
              onChange={(event) => setAgendaForm((prev) => ({ ...prev, title: event.target.value }))}
              className="mt-1 w-full rounded-xl border border-brand-border px-3 py-2 text-sm"
            />
          </label>
        </div>
        <label className="text-sm text-slate-600">
          Описание
          <textarea
            value={agendaForm.description}
            onChange={(event) => setAgendaForm((prev) => ({ ...prev, description: event.target.value }))}
            className="mt-1 w-full rounded-xl border border-brand-border px-3 py-2 text-sm"
            rows={3}
          />
        </label>
        <PrimaryButton onClick={() => void createAgenda()} className="px-4 py-2">
          Создать повестку
        </PrimaryButton>
      </Card>
    </div>
  );

  function moveSection(index: number, delta: number) {
    setReport((prev) => {
      const copy = [...prev.sections];
      const target = index + delta;
      if (target < 0 || target >= copy.length) return prev;
      const [removed] = copy.splice(index, 1);
      copy.splice(target, 0, removed);
      return { ...prev, sections: copy.map((s, idx) => ({ ...s, orderIndex: idx })) };
    });
  }

  async function updateMeta(status: "finalized") {
    setError(null);
    const response = await fetch(`/api/app/reports/${report.id}`, {
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ status }),
    });
    const payload = await response.json().catch(() => null);
    if (response.ok && payload?.ok) {
      setReport(payload.report);
    } else {
      setError(payload?.error?.message ?? "Не удалось обновить статус");
    }
  }
}

function formatType(type: string) {
  const map: Record<string, string> = { team: "Команда", pilot: "Пилот", workspace: "Организация" };
  return map[type] ?? type;
}

function formatStatus(status: string) {
  const map: Record<string, string> = { draft: "Черновик", finalized: "Финализировано", archived: "Архив" };
  return map[status] ?? status;
}
